---
layout: post
title: 从最简单的排序到简单选择排序
date: 2019-02-27
tags: ["日志","计算机基础知识"]
categories:
- 计算机
---

![选择排序](select_sort.png "选择排序")

在[写好冒泡排序](https://www.xiaobotalk.com/archives/440)一文中提到了，我们最容易想到，也是最简单的排序代码：

    void bubbleSort0 (int arr[], int len) 
    {
        int i, j, temp;
        for (i = 0; i < len; i++) {
            for (j = i + 1; j < len; j++) {
                if (arr[i] > arr[j]) { 
                    // 用当前待排序索引和剩余所有未排序位进行比较 如果大于当前字符，就交互。
                    temp = arr[j];
                    arr[j] = arr[i];
                    arr[i] = temp;
                }
            }
        }
    }

上边代码不但不是严格的冒泡排序，反而有一种选择排序的味道，因为每轮外循环都是为了**在待排序序列中选择出一个最小的元素**。

## 简单选择排序算法

简单选择排序算法，就是通过 n - i 次比较，从 n - i + 1 个记录中选择出最小元素，只不过我们在寻找最小记录的过程中，只需要交互元素下标即可。最终确定了最小元素下标后，再交互元素位置。

    void selectSort(int arr[], int len)
    {
        int i, j, min;

        for (i = 0; i < len; i++) {

            min = i;
            for (j = i + 1; j < len; j++) {
                if (arr[min] > arr[j]) {
                    // 与上述代码不同的是，我们只交换元素下标，记录一轮循环中的最小记录
                    min = j;
                }
            }
            if (i != min) {
                // 找到了有效的最小元素下标，交换位置
                int temp = arr[i];
                arr[i] = arr[min];
                arr[min] = temp;
            }
        }
    }

与第一段代码相比，其实很类似，只不过我们不需要每次比较元素大小的时候都进行元素交换，而是确定找到了本轮查找中最小元素后，再进行有效交换。

## 简单选择排序的复杂度分析

无论最好还是最坏情况，简单选择排序算法的比较次数都是一样多的，即：(n - 1) + (n -2) + ...+ 3 + 2 + 1 =  $\frac{n(n-1)}{2}$  次。

而对于交换次数而言，最好的情况下，0 次交换；最差的情况，交换次数为 n - 1 次。所以总的时间复杂度是 $\frac{n(n-1)}{2}$  + (n - 1) ，根据复杂度分析的加法法则，总的时间复杂度是 O($n^2$)。

但它最大的特点是交换移动数据的次数相当少，这样也就节约了相应的时间。尽管与冒泡排序同为 O($n^2$) ，但简单选择排序的性能还是要略微优于冒泡排序。

(完)